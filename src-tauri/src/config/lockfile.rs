use crate::error::{CogniaError, CogniaResult};
use crate::platform::fs;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

pub const LOCKFILE_FILENAME: &str = "CogniaLauncher-lock.yaml";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    pub lockfile_version: u32,
    pub generated_at: DateTime<Utc>,
    pub generated_by: String,
    #[serde(default)]
    pub environments: HashMap<String, LockedEnvironment>,
    #[serde(default)]
    pub packages: Vec<LockedPackage>,
    pub dependency_graph_hash: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedEnvironment {
    pub version: String,
    pub provider: String,
    pub resolved_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    pub name: String,
    pub version: String,
    pub provider: String,
    pub checksum: Option<ChecksumInfo>,
    pub source: Option<LockedSource>,
    #[serde(default)]
    pub artifacts: HashMap<String, LockedArtifact>,
    pub resolved_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChecksumInfo {
    pub sha256: Option<String>,
    pub sha512: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedSource {
    pub github: Option<String>,
    pub tag: Option<String>,
    pub url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedArtifact {
    pub url: String,
    pub checksum: ChecksumInfo,
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

impl Lockfile {
    pub fn new() -> Self {
        Self {
            lockfile_version: 1,
            generated_at: Utc::now(),
            generated_by: format!("CogniaLauncher/{}", env!("CARGO_PKG_VERSION")),
            environments: HashMap::new(),
            packages: Vec::new(),
            dependency_graph_hash: None,
        }
    }

    pub async fn load(path: &Path) -> CogniaResult<Self> {
        let content = fs::read_file_string(path).await?;
        let lockfile: Lockfile = serde_yaml::from_str(&content)
            .map_err(|e| CogniaError::Parse(format!("Failed to parse lockfile: {}", e)))?;
        Ok(lockfile)
    }

    pub async fn load_from_dir(dir: &Path) -> CogniaResult<Option<Self>> {
        let lockfile_path = dir.join(LOCKFILE_FILENAME);

        if !fs::exists(&lockfile_path).await {
            return Ok(None);
        }

        let lockfile = Self::load(&lockfile_path).await?;
        Ok(Some(lockfile))
    }

    pub async fn save(&self, path: &Path) -> CogniaResult<()> {
        let header = "# This file is auto-generated by CogniaLauncher. Do not edit manually.\n\n";
        let content = serde_yaml::to_string(self)
            .map_err(|e| CogniaError::Config(format!("Failed to serialize lockfile: {}", e)))?;

        let full_content = format!("{}{}", header, content);
        fs::write_file_atomic(path, full_content.as_bytes()).await?;
        Ok(())
    }

    pub fn lock_environment(&mut self, env_type: &str, version: &str, provider: &str) {
        self.environments.insert(
            env_type.to_string(),
            LockedEnvironment {
                version: version.to_string(),
                provider: provider.to_string(),
                resolved_at: Utc::now(),
            },
        );
        self.generated_at = Utc::now();
    }

    pub fn lock_package(&mut self, package: LockedPackage) {
        if let Some(idx) = self.packages.iter().position(|p| p.name == package.name) {
            self.packages[idx] = package;
        } else {
            self.packages.push(package);
        }
        self.generated_at = Utc::now();
    }

    pub fn get_environment_version(&self, env_type: &str) -> Option<&str> {
        self.environments.get(env_type).map(|e| e.version.as_str())
    }

    pub fn get_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }

    pub fn remove_package(&mut self, name: &str) -> bool {
        let len_before = self.packages.len();
        self.packages.retain(|p| p.name != name);
        self.packages.len() != len_before
    }

    pub fn update_hash(&mut self) {
        use sha2::{Digest, Sha256};

        let mut hasher = Sha256::new();

        for (env_type, env) in &self.environments {
            hasher.update(env_type.as_bytes());
            hasher.update(env.version.as_bytes());
        }

        for pkg in &self.packages {
            hasher.update(pkg.name.as_bytes());
            hasher.update(pkg.version.as_bytes());
        }

        self.dependency_graph_hash = Some(hex::encode(hasher.finalize()));
    }
}

impl LockedPackage {
    pub fn new(name: &str, version: &str, provider: &str) -> Self {
        Self {
            name: name.to_string(),
            version: version.to_string(),
            provider: provider.to_string(),
            checksum: None,
            source: None,
            artifacts: HashMap::new(),
            resolved_at: Utc::now(),
        }
    }

    pub fn with_checksum(mut self, sha256: Option<String>) -> Self {
        self.checksum = Some(ChecksumInfo {
            sha256,
            sha512: None,
        });
        self
    }

    pub fn with_source(mut self, source: LockedSource) -> Self {
        self.source = Some(source);
        self
    }

    pub fn add_artifact(&mut self, platform_arch: &str, artifact: LockedArtifact) {
        self.artifacts.insert(platform_arch.to_string(), artifact);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_lockfile() {
        let lockfile = Lockfile::new();
        assert_eq!(lockfile.lockfile_version, 1);
        assert!(lockfile.environments.is_empty());
        assert!(lockfile.packages.is_empty());
    }

    #[test]
    fn test_lock_environment() {
        let mut lockfile = Lockfile::new();
        lockfile.lock_environment("node", "18.19.0", "nvm");

        assert_eq!(lockfile.get_environment_version("node"), Some("18.19.0"));
    }

    #[test]
    fn test_lock_package() {
        let mut lockfile = Lockfile::new();
        let pkg = LockedPackage::new("ripgrep", "14.0.3", "github");
        lockfile.lock_package(pkg);

        let locked = lockfile.get_package("ripgrep").unwrap();
        assert_eq!(locked.version, "14.0.3");
    }

    #[test]
    fn test_serialize_deserialize() {
        let mut lockfile = Lockfile::new();
        lockfile.lock_environment("node", "20.0.0", "nvm");
        lockfile.lock_package(LockedPackage::new("git", "2.43.0", "apt"));

        let yaml = serde_yaml::to_string(&lockfile).unwrap();
        let parsed: Lockfile = serde_yaml::from_str(&yaml).unwrap();

        assert_eq!(parsed.get_environment_version("node"), Some("20.0.0"));
    }
}
